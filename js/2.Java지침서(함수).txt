 < 함수와 객체 >
------------------------------------------------------------------
01. 함수의 마법, 코드를 재사용하는 첫 번째 방법
------------------------------------------------------------------
함수(Function)는 특정한 작업을 수행하는 코드들을 하나의 묶음으로 만들어둔 것입니다.
마치 만능 도구상자처럼, 필요할 때마다 꺼내서 사용할 수 있어요.

< 함수가 필요한 이유 >
1. 재사용성: 한 번 만들면 여러 번 사용 가능
2. 유지보수: 수정할 때 한 곳만 고치면 됨
3. 가독성: 코드가 깔끔하고 이해하기 쉬워짐

< 함수의 기본 구조 >
JavaScript에서 함수는 다음과 같은 구조를 가집니다.
------------------------------------------------------------------
function 함수이름() {
 // 실행할 코드
}
------------------------------------------------------------------
실생활로 비유하면, 함수는 자판기와 같습니다.
- 함수 이름: 자판기에 붙은 라벨 (예: "콜라 자판기")
- 함수 내용: 자판기 안의 동작 메커니즘
- 함수 호출: 버튼을 눌러서 원하는 음료 받기


------------------------------------------------------------------
매개변수와 인수, 함수에 정보 전달하기
------------------------------------------------------------------
매개변수와 인수, 뭐가 다른 걸까?
함수를 "요리사"라고 생각해보세요. 요리사가 요리를 만들 때 재료가 필요하죠?

매개변수(Parameter): 함수를 정의할 때 괄호 안에 적는 변수명 (요리사가 "재료통"이라고 부르는 빈 그릇)
인수(Argument): 함수를 호출할 때 실제로 전달하는 값 (실제 재료)

자주 발생하는 오류와 해결책:
- 오류: 매개변수 순서를 바꿔서 호출   ( 잘 설정하거나.. 혹은 잘 기억하거나.. )
- 해결: 함수 정의를 다시 확인하고 순서대로 인수 전달
- 오류: 필요한 인수를 전달하지 않음
- 해결: 기본값 설정하거나 모든 필수 인수 전달

[ 핵심 내용 요약 ]
매개변수: 함수 정의 시 괄호 안의 변수명 (빈 그릇)
인수: 함수 호출 시 실제 전달하는 값 (실제 재료)
순서 중요: 인수는 매개변수 순서대로 전달됨
기본값: 인수가 없을 때 사용할 값을 미리 설정 가능
------------------------------------------------------------------


------------------------------------------------------------------
 함수의 반환값, 결과를 돌려받는 방법
------------------------------------------------------------------
함수의 반환값(return value)은 함수가 작업을 완료한 후 호출한 곳으로 돌려주는 결과입니다.
마치 자판기에 동전을 넣고 버튼을 누르면 음료수가 나오는 것처럼,
함수에 값을 전달하면 처리된 결과를 돌려받을 수 있습니다.

return문의 역할
1. 결과 반환: 함수가 계산한 값을 호출한 곳으로 돌려줍니다
2. 함수 종료: return문을 만나면 함수 실행이 즉시 종료됩니다
3. 값의 전달: 어떤 타입의 값이든 반환할 수 있습니다

------------------------------------------------------------------
기본적인 return 사용법
------------------------------------------------------------------
function add(a, b) {
 return a + b; // 계산 결과를 반환
}

let result = add(5, 3); // 8이 result에 저장됨
console.log(result); // 8 출력
------------------------------------------------------------------
return은 함수의 '출구'라고 생각하면 됩니다.
함수 안에서 일어난 모든 일의 결과를 가지고 밖으로 나가죠.
------------------------------------------------------------------



------------------------------------------------------------------
함수 스코프와 클로저, 변수의 은밀한 세계
------------------------------------------------------------------
함수 스코프(Function Scope)는 변수가 살아있는 '영역'을 의미합니다.
마치 아파트에서 각 세대마다 독립적인 공간을 가지는 것처럼,
함수도 자신만의 독립적인 변수 공간을 가집니다.
------------------------------------------------------------------
let globalMessage = "전역 변수입니다"; // 전역 스코프

function showMessage() {
 let localMessage = "지역 변수입니다"; // 함수 스코프 (지역 변수)
 console.log(globalMessage); // 전역 변수 접근 가능
 console.log(localMessage); // 지역 변수 접근 가능
}

showMessage(); // 정상 실행
console.log(globalMessage); // 전역 변수 접근 가능
// console.log(localMessage); // 오류! 함수 밖에서는 접근 불가
------------------------------------------------------------------
전역 변수는 모든 곳에서 접근할 수 있는 '공용 공간'의 변수이고,
지역 변수는 특정 함수 안에서만 사용할 수 있는 '개인 방'의 변수입니다.

클로저(Closure)는 함수가 자신이 생성될 때의 환경을 '기억'하는 특별한 능력입니다.
마치 추억이 담긴 보물상자를 간직하는 것처럼,
함수는 자신이 만들어진 순간의 변수들을 계속 기억하고 있습니다.
------------------------------------------------------------------
function createCounter() {
 let count = 0; // 외부에서 직접 접근할 수 없는 '비밀' 변수

 return function() {
 count++; // 클로저를 통해 count에 접근
 return count;
 };
}

let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
------------------------------------------------------------------
[ 내용 요약 ]
핵심 내용 요약:
- 함수 스코프: 함수마다 독립적인 변수 영역을 가짐
- 전역 변수: 모든 곳에서 접근 가능하지만 남용하면 위험
- 지역 변수: 함수 내에서만 사용 가능하여 안전함
- 클로저: 함수가 생성 시점의 환경을 기억하는 특별한 능력
------------------------------------------------------------------


------------------------------------------------------------------
화살표 함수, 더 '간결'하고 '현대적'인 함수 작성법
------------------------------------------------------------------
화살표 함수(Arrow Function)는 JavaScript ES6에서 도입된 새로운 함수 표현 방식입니다
기존의 function 키워드를 사용한 함수 선언보다 더 간결하고 현대적인 문법을 제공합니다.
------------------------------------------------------------------
[ 화살표 함수의 기본 문법 ]
------------------------------------------------------------------
화살표 함수는 => 기호를 사용해서 만듭니다.
마치 "입력 ⇒ 출력"을 나타내는 수학 공식처럼 직관적입니다.
------------------------------------------------------------------
( 기존 함수 표현식 )
const add = function(a, b) {
 return a + b;
};
------------------------------------------------------------------
( 화살표 함수 )
const add = (a, b) => {
 return a + b;
};
------------------------------------------------------------------
( 더 간단하게 줄일때 )
const add = (a, b) => a + b;
------------------------------------------------------------------
[ 화살표 함수의 다양한 형태 ]
------------------------------------------------------------------
( 매개변수가 없는 경우 )
const sayHello = () => console.log('안녕하세요!');
------------------------------------------------------------------
( 매개변수가 하나인 경우 ) ( 괄호 생략 가능 )
const double = x => x * 2;
const greet = name => `안녕하세요, ${name}님!`;
------------------------------------------------------------------
( 매개 변수가 여러개인 경우 )
const multiply = (a, b, c) => a * b * c;
------------------------------------------------------------------
( 함수 본문이 여러 줄인 경우 )
const processData = (data) => {
 const processed = data.filter(item => item > 0);
 const doubled = processed.map(item => item * 2);
 return doubled;
};
------------------------------------------------------------------
화살표 함수는 특히 콜백 함수로 많이 사용됩니다.
배열 메서드나 이벤트 핸들러에서 정말 유용합니다!
------------------------------------------------------------------
[ 내용 정리 ]
화살표 함수는 현대 JavaScript 개발에서 필수적인 문법입니다.
기존 함수보다 간결하고 읽기 쉬우며,
특히 콜백 함수로 사용할 때 그 진가를 발휘합니다.

핵심 포인트:
- => 기호로 함수 생성
- 매개변수가 하나면 괄호 생략 가능
- 함수 본문이 한 줄이면 중괄호와 return 생략 가능
- 배열 메서드와 이벤트 핸들러에서 특히 유용
------------------------------------------------------------------


------------------------------------------------------------------
[ 고차 함수, 함수를 다루는 함수의 세계 ]
------------------------------------------------------------------
고차 함수(Higher-Order Function)는 함수를 인자로 받거나 함수를 반환하는 함수입니다.
이는 함수형 프로그래밍의 핵심 개념 중 하나로, JavaScript에서 매우 강력한 기능입니다.

고차 함수를 이해하기 위해 공장의 생산 라인을 생각해보세요.
원재료(데이터)가 들어가면 각 단계(함수)를 거쳐 최종 제품이 나옵니다.
고차 함수는 이 생산 라인을 관리하는 공장장과 같은 역할을 합니다.

JavaScript 배열에는 대표적인 고차 함수들이 내장되어 있습니다.

1. map(): 각 요소를 변환하여 새로운 배열 생성
2. filter(): 조건에 맞는 요소만 골라서 새로운 배열 생성
3. reduce(): 배열의 모든 요소를 하나의 값으로 축약
4. forEach(): 각 요소에 대해 함수 실행

이들은 모두 콜백 함수를 인자로 받아서 배열의 각 요소에 적용합니다.
마치 요리사가 재료마다 다른 조리법을 적용하는 것과 같죠.

주의사항: 고차 함수는 순수 함수로 작성하는 것이 좋습니다.
즉, 입력이 같으면 항상 같은 출력을 반환하고, 외부 상태를 변경하지 않아야 합니다.
------------------------------------------------------------------


------------------------------------------------------------------
[ 객체 심화, 데이터와 기능을 함께 묶기 ]
------------------------------------------------------------------
객체 메소드(Method)는 객체 안에 정의된 함수를 말합니다.
마치 스마트폰을 생각해보세요.
스마트폰 안에는 배터리 잔량, 저장 공간 같은 데이터도 있고,
전화 걸기, 사진 찍기 같은 기능도 함께 들어있죠.
객체 메소드도 이와 같은 원리입니다.
------------------------------------------------------------------
< 기본적인 객체 메소드 정의 >
const user = {
 name: "김개발",
 age: 20,
 email: "kimdev@example.com",
------------------------------------------------------------------
 < 메소드 정의 방법 1: 함수 표현식 >
 introduce: function() {
 return `안녕하세요! 저는 ${this.name}입니다.`;
 },
------------------------------------------------------------------
 < 메소드 정의 방법 2: 단축 문법 (ES6+) >
 getAge() {
 return `저는 ${this.age}살입니다.`;
 },
------------------------------------------------------------------
 < 메소드 정의 방법 3: 화살표 함수 (주의: this 동작이 다름) >
 getEmail: () => {
 // 화살표 함수에서는 this가 제대로 동작하지 않음
 return "이메일 정보";
 }
};
------------------------------------------------------------------
[ this 키워드 이해하기 ]
------------------------------------------------------------------
this는 현재 객체를 가리키는 특별한 키워드입니다.
마치 "나 자신"을 가리키는 것과 같아요.
------------------------------------------------------------------
const calculator = {
 result: 0,

add(number) {
 this.result += number; // this는 calculator 객체를 가리킴
 return this; // 메소드 체이닝을 위해 자기 자신을 반환
 },

 subtract(number) {
 this.result -= number;
 return this;
 },

 multiply(number) {
 this.result *= number;
 return this;
 },

 getResult() {
 return this.result;
 },

 reset() {
 this.result = 0;
 return this;
 }
};
------------------------------------------------------------------
[ 내용 정리 ]
메소드: 객체 안에 정의된 함수
this 키워드: 현재 객체를 가리키는 참조
메소드 체이닝: return this로 연속 호출 가능
캡슐화: 관련된 데이터와 기능을 하나로 묶어 관리
------------------------------------------------------------------


------------------------------------------------------------------
배열 고급 활용, 데이터 조작의 달인 되기
------------------------------------------------------------------
배열의 sort() 메소드는 마치 도서관 사서와 같은 역할을 합니다.
책들이 아무렇게나 꽂혀있는 서가를 보고,
제목 순서대로, 또는 출판연도 순서대로 정리하는 것처럼 말이죠.

가장 기본적인 sort()는 문자열 기준으로 정렬합니다.
이는 컴퓨터가 모든 데이터를 문자로 변환해서 비교하기 때문입니다.
하지만 실제 개발에서는 숫자 크기 순서대로, 또는 특정 조건에 따라 정렬해야 하는 경우가 많습니다.

이때 비교 함수(compare function)를 사용합니다.
이 함수는 두 개의 값을 받아서 어떤 것이 앞에 와야 하는지 결정하는 심판 역할을 합니다.

- 음수를 반환하면: 첫 번째 값이 앞으로
- 0을 반환하면: 순서 변경 없음
- 양수를 반환하면: 두 번째 값이 앞으로

------------------------------------------------------------------
< 기본 문자열 정렬 > (주의: 숫자도 문자로 취급!)
let numbers = [10, 5, 40, 25, 1000, 1];
console.log(numbers.sort());

결과 : [1, 10, 1000, 25, 40, 5] - 원하는 결과가 아님!

< 숫자 크기 순 정렬 >
console.log(numbers.sort((a, b) => a - b));

결과 : [1, 5, 10, 25, 40, 1000] - 올바른 결과!
------------------------------------------------------------------
[ 학생 점수 배열 정렬하기 ]
let scores = [85, 92, 78, 96, 88, 74];

[ 오름차순 정렬 ](낮은 점수부터)
let ascending = scores.sort((a, b) => a - b);
console.log("오름차순:", ascending);

결과 : [74, 78, 85, 88, 92, 96]

[ 내림차순 정렬 ](높은 점수부터)
let descending = scores.sort((a, b) => b - a);
console.log("내림차순:", descending);

결과 : [96, 92, 88, 85, 78, 74]

[ 문자열 배열 정렬 ]
let names = ["김개발", "박멘토", "이디자인", "최기획"];
let sortedNames = names.sort();
console.log("이름순:", sortedNames);

결과 : 한글도 가나다 순으로 정렬됩니다!

------------------------------------------------------------------
비교 함수를 사용하면 숫자 크기순, 객체의 특정 속성순,
심지어 복합 조건까지 자유자재로 정렬할 수 있죠.
------------------------------------------------------------------


------------------------------------------------------------------
[ 구조 분해 할당, 데이터 추출의 새로운 방법 ]
------------------------------------------------------------------
구조 분해 할당(Destructuring Assignment)은 배열이나 객체의 속성을 해체하여
그 값을 개별 변수에 담을 수 있게 해주는 JavaScript의 강력한 기능입니다.
마치 택배 상자를 열어서 각각의 물건을 정리된 서랍에 넣는 것과 같다고 생각하면 됩니다.
------------------------------------------------------------------
기존 방식과 구조 분해 할당을 비교해보겠습니다.
------------------------------------------------------------------
[ 기존 방식 - 하나씩 꺼내기 ]
const fruits = ['사과', '바나나', '오렌지'];
const first = fruits[0];
const second = fruits[1];
const third = fruits[2];

// 구조 분해 할당 - 한 번에 꺼내기
const [apple, banana, orange] = fruits;
------------------------------------------------------------------
구조 분해 할당의 핵심 장점은 다음과 같습니다.

코드 간소화: 여러 줄의 할당을 한 줄로 처리
가독성 향상: 의도가 명확하게 드러남
실수 방지: 인덱스 번호를 잘못 쓸 위험 감소
유지보수성: 변수명으로 데이터의 의미를 명확히 표현
------------------------------------------------------------------
실무에서는 API 응답 데이터를 처리할 때 특히 유용합니다.
서버에서 [userName, userAge, userEmail] 형태로 데이터가 오면
구조 분해 할당으로 깔끔하게 변수에 담을 수 있습니다.
------------------------------------------------------------------
[ 요약 정리 ]
- const [변수1, 변수2] = 배열 형태로 사용
- 요소 건너뛰기: const [a, , c] = 배열
- 기본값 설정: const [a, b = 기본값] = 배열
- 나머지 요소: const [first, ...rest] = 배열
------------------------------------------------------------------


------------------------------------------------------------------
[ 전개 연산자, 배열과 객체를 자유자재로 다루기 ]
------------------------------------------------------------------
전개 연산자(Spread Operator)는 ...로 표현되며,
배열이나 객체의 요소들을 개별적으로 펼쳐주는 연산자입니다.
마치 선물 상자를 열어서 안의 내용물을 하나씩 꺼내는 것과 같다고 생각하면 됩니다.

예를들어 여러 개의 사과가 든 바구니가 있다면,
전개 연산자는 그 바구니를 뒤집어서 사과들을 하나씩 꺼내는 역할을 합니다.
------------------------------------------------------------------
전개 연산자의 주요 활용법은 다음과 같습니다.
------------------------------------------------------------------
배열 복사: 기존 배열을 손상시키지 않고 새로운 배열 생성
배열 합치기: 여러 배열을 하나로 결합
객체 복사: 객체의 속성들을 새로운 객체로 복사
함수 인자 전달: 배열의 요소들을 개별 인자로 전달
------------------------------------------------------------------
이는 불변성(Immutability)을 유지하는 중요한 방법입니다.
원본 데이터를 변경하지 않고 새로운 데이터를 만들어내기 때문에,
예상치 못한 버그를 방지할 수 있습니다.
------------------------------------------------------------------
[ 요약 정리 ]
전개 연산자는 배열과 객체를 다루는 현대적이고 효율적인 방법입니다.
원본 데이터를 보호하면서 새로운 데이터 구조를 만들 수 있어,
안전하고 예측 가능한 코드를 작성할 수 있습니다.

- ...로 배열과 객체를 펼칠 수 있다.
- 원본을 변경하지 않고 새로운 데이터를 생성한다.
- 배열 합치기, 객체 병합, 함수 인자 전달에 활용된다.
- 얕은 복사를 수행하므로 중첩 구조 주의가 필요하다.
------------------------------------------------------------------